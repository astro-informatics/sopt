#ifndef SOPT_TESTME
#define  SOPT_TESTME
#include <Eigen/Core>
#include <iostream>
#include <wavelets.h>
#include <sopt/types.h>

namespace sopt { namespace pyWavelets{
  //! Convert 1D or 2D data from cython in either double or complex format to Eigen matrix. 
  template<class T>
    Eigen::Matrix<T,Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>
    from_pymat_to_eigen_mat(T *pyMat, const int nrow, const int ncol){
      typedef Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> t_pyMatrix;
      t_pyMatrix eigenMat(nrow, ncol);
      eigenMat = Eigen::Map<t_pyMatrix>(&pyMat[0], nrow, ncol);
      return(eigenMat);
    }

  //! \brief direct transform wrapper called by cython
  //! \param[in] py_input: double or complex pointer of input data generated by cython code.
  //! \param[in] name: Daubechie wavelets coefficient.
  //! \param[in] level: wavelet transform level.
  //! \param[in] nrow/ncol: number of rows and columns of input data. In the case of a vector 
  //!                       input, ncol = 1.
  //! \param[out] py_out: result data in either double or complex pointer.
  template <class T>
    void direct(T *py_input, T* py_output, const std::string name, const t_uint level,
        const int nrow, const int ncol){
      auto const wavelets = sopt::wavelets::factory(name, level);
      auto eigen_input  = from_pymat_to_eigen_mat(py_input, nrow, ncol);
      //! 
      if(eigen_input.cols() == 1){
        auto coefficient = wavelets.direct(eigen_input.col(0).array());
        for(int i=0; i<nrow*ncol; ++i)
          py_output[i] = coefficient.data()[i];
      }
      else{
        auto coefficient = wavelets.direct(eigen_input.array());
        for(int i=0; i<nrow*ncol; ++i)
          py_output[i]=coefficient.data()[i];
      }
    };
  //! \brief indirect transform wrapper called by cython
  //! \param[in] py_input: double or complex pointer of input data generated by cython code.
  //! \param[in] name: Daubechie wavelets coefficient.
  //! \param[in] level: wavelet transform level.
  //! \param[in] nrow/ncol: number of rows and columns of input data. In the case of a vector 
  //!                       input, ncol = 1.
  //! \param[out] py_out: result data in either double or complex pointer.
  template <class T>
    void indirect(T *py_input, T *py_output,const std::string name, const t_uint level,\
        const int nrow, const int ncol){
      auto const wavelets = sopt::wavelets::factory(name, level);
      auto const eigen_input  = from_pymat_to_eigen_mat(py_input, nrow, ncol);
      if(eigen_input.cols() == 1){
        auto coefficient = wavelets.indirect(eigen_input.col(0).array());
        for(int i=0; i<nrow*ncol; ++i)
          py_output[i]=coefficient.data()[i];
      }
      else{
        auto coefficient = wavelets.indirect(eigen_input.array());
        for(int i=0; i<nrow*ncol; ++i)
          py_output[i]=coefficient.data()[i];
      }
    };
}}


#endif
