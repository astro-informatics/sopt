<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SOPT: sopt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SOPT
   </div>
   <div id="projectbrief">Sparse OPTimisation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sopt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesopt_1_1algorithm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1algorithm.html">algorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1cppflowutils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1cppflowutils.html">cppflowutils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1credible__region"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1credible__region.html">credible_region</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1gradient__operator"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1gradient__operator.html">gradient_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1logging"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1logging.html">logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1mpi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1mpi.html">mpi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1objective__functions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1objective__functions.html">objective_functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1proximal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1proximal.html">proximal</a></td></tr>
<tr class="memdesc:namespacesopt_1_1proximal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds some standard proximals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1tools.html">tools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1utilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1utilities.html">utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesopt_1_1wavelets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt_1_1wavelets.html">wavelets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1ConjugateGradient.html">ConjugateGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves $Ax = b$ for $x$, given $A$ and $b$.  <a href="classsopt_1_1ConjugateGradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root exception for sopt.  <a href="classsopt_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1L2DifferentiableFunc.html">L2DifferentiableFunc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins together direct and indirect operators.  <a href="classsopt_1_1LinearTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1ONNXDifferentiableFunc.html">ONNXDifferentiableFunc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1ORTsession.html">ORTsession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sopt interface class to hold a ONNXrt session.  <a href="classsopt_1_1ORTsession.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsopt_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if underlying type is complex.  <a href="structsopt_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsopt_1_1is__complex_3_01std_1_1complex_3_01T_01_4_00_01void_01_4.html">is_complex&lt; std::complex&lt; T &gt;, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if underlying type is complex.  <a href="structsopt_1_1is__complex_3_01std_1_1complex_3_01T_01_4_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1RelativeVariation.html">RelativeVariation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1ScalarRelativeVariation.html">ScalarRelativeVariation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsopt_1_1Sampling.html">Sampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that samples a set of measurements.  <a href="classsopt_1_1Sampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsopt_1_1CData.html">CData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7ee75936aaae93251b12abb77c3e02aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ee75936aaae93251b12abb77c3e02aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a> = <a class="el" href="classsopt_1_1details_1_1underlying__value__type.html">details::underlying_value_type</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a7ee75936aaae93251b12abb77c3e02aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets to the underlying real type.  <a href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">More...</a><br /></td></tr>
<tr class="separator:a7ee75936aaae93251b12abb77c3e02aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47796df8f5f6bbffc226292ef1ca8196"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a> = int</td></tr>
<tr class="memdesc:a47796df8f5f6bbffc226292ef1ca8196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the type hierarchy for signed integers.  <a href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">More...</a><br /></td></tr>
<tr class="separator:a47796df8f5f6bbffc226292ef1ca8196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237c0991f6ec8c2bbdab8929b564964"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a> = size_t</td></tr>
<tr class="memdesc:a7237c0991f6ec8c2bbdab8929b564964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the type hierarchy for unsigned integers.  <a href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">More...</a><br /></td></tr>
<tr class="separator:a7237c0991f6ec8c2bbdab8929b564964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bfb8f70b432862d3d654b9dcff77cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a> = double</td></tr>
<tr class="memdesc:a71bfb8f70b432862d3d654b9dcff77cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the type hierarchy for real numbers.  <a href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">More...</a><br /></td></tr>
<tr class="separator:a71bfb8f70b432862d3d654b9dcff77cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24bc0cbf4f1391b3d1440213329d13f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a> = std::complex&lt; <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a> &gt;</td></tr>
<tr class="memdesc:ad24bc0cbf4f1391b3d1440213329d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the type hierarchy for (real) complex numbers.  <a href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">More...</a><br /></td></tr>
<tr class="separator:ad24bc0cbf4f1391b3d1440213329d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dd3feebe1bf49ebd44d72b05064c19"><td class="memTemplParams" colspan="2">template&lt;typename T  = t_real&gt; </td></tr>
<tr class="memitem:ac4dd3feebe1bf49ebd44d72b05064c19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a> = <a class="el" href="tf__inpainting_8cc.html#ab86a00c212fb2233871e057014ded6a6">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:ac4dd3feebe1bf49ebd44d72b05064c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of a given type.  <a href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">More...</a><br /></td></tr>
<tr class="separator:ac4dd3feebe1bf49ebd44d72b05064c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedb6b3e862bd2968bf3026599121630"><td class="memTemplParams" colspan="2">template&lt;typename T  = t_real&gt; </td></tr>
<tr class="memitem:adedb6b3e862bd2968bf3026599121630"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#adedb6b3e862bd2968bf3026599121630">Matrix</a> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:adedb6b3e862bd2968bf3026599121630"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of a given type.  <a href="namespacesopt.html#adedb6b3e862bd2968bf3026599121630">More...</a><br /></td></tr>
<tr class="separator:adedb6b3e862bd2968bf3026599121630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de8d7c976f608fe47220203047b5cb8"><td class="memTemplParams" colspan="2">template&lt;typename T  = t_real&gt; </td></tr>
<tr class="memitem:a9de8d7c976f608fe47220203047b5cb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a9de8d7c976f608fe47220203047b5cb8">Array</a> = Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a9de8d7c976f608fe47220203047b5cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 1-dimensional list of elements of given type.  <a href="namespacesopt.html#a9de8d7c976f608fe47220203047b5cb8">More...</a><br /></td></tr>
<tr class="separator:a9de8d7c976f608fe47220203047b5cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7971e5566e597eb907614917e30c78"><td class="memTemplParams" colspan="2">template&lt;typename T  = t_real&gt; </td></tr>
<tr class="memitem:a7d7971e5566e597eb907614917e30c78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">Image</a> = Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a7d7971e5566e597eb907614917e30c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional list of elements of given type.  <a href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">More...</a><br /></td></tr>
<tr class="separator:a7d7971e5566e597eb907614917e30c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4353f012100677172534381f2801fa9"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR  = Vector&lt;&gt;&gt; </td></tr>
<tr class="memitem:aa4353f012100677172534381f2801fa9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a> = std::function&lt; void(VECTOR &amp;, VECTOR const &amp;)&gt;</td></tr>
<tr class="memdesc:aa4353f012100677172534381f2801fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typical function out = A*x.  <a href="namespacesopt.html#aa4353f012100677172534381f2801fa9">More...</a><br /></td></tr>
<tr class="separator:aa4353f012100677172534381f2801fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf84f975b1aa24c2925150488215df2"><td class="memTemplParams" colspan="2">template&lt;typename SCALAR  = t_real&gt; </td></tr>
<tr class="memitem:acbf84f975b1aa24c2925150488215df2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#acbf84f975b1aa24c2925150488215df2">ProximalFunction</a> = std::function&lt; void(<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; SCALAR &gt; &amp;output, typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; SCALAR &gt;::type const weight, <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; SCALAR &gt; const &amp;input)&gt;</td></tr>
<tr class="memdesc:acbf84f975b1aa24c2925150488215df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typical function signature for calls to proximal.  <a href="namespacesopt.html#acbf84f975b1aa24c2925150488215df2">More...</a><br /></td></tr>
<tr class="separator:acbf84f975b1aa24c2925150488215df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc375c693a8c32c2a954d17a7773b7f8"><td class="memTemplParams" colspan="2">template&lt;typename SCALAR  = t_real&gt; </td></tr>
<tr class="memitem:acc375c693a8c32c2a954d17a7773b7f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#acc375c693a8c32c2a954d17a7773b7f8">ConvergenceFunction</a> = std::function&lt; bool(<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; SCALAR &gt; const &amp;)&gt;</td></tr>
<tr class="memdesc:acc375c693a8c32c2a954d17a7773b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typical function signature for convergence.  <a href="namespacesopt.html#acc375c693a8c32c2a954d17a7773b7f8">More...</a><br /></td></tr>
<tr class="separator:acc375c693a8c32c2a954d17a7773b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7574fac5dcbb3569bad1e0d08a553406"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a7574fac5dcbb3569bad1e0d08a553406"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a>, K &gt;::value, K &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a7574fac5dcbb3569bad1e0d08a553406">bisection_method</a> (const K &amp;function_value, const std::function&lt; K(K)&gt; &amp;func, const K &amp;<a class="el" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>, const K &amp;<a class="el" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>, const <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a> &amp;rel_convergence=1e-4)</td></tr>
<tr class="memdesc:a7574fac5dcbb3569bad1e0d08a553406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find root to a function within an interval.  <a href="namespacesopt.html#a7574fac5dcbb3569bad1e0d08a553406">More...</a><br /></td></tr>
<tr class="separator:a7574fac5dcbb3569bad1e0d08a553406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8a990d75711b892ac8bf2f030d8c1e"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename... T&gt; </td></tr>
<tr class="memitem:a5e8a990d75711b892ac8bf2f030d8c1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; T0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a5e8a990d75711b892ac8bf2f030d8c1e">chained_operators</a> (<a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; T0 &gt; const &amp;arg0, T const &amp;... args)</td></tr>
<tr class="separator:a5e8a990d75711b892ac8bf2f030d8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad09b58521217893f8f6bb076ade261b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#aad09b58521217893f8f6bb076ade261b">version</a> ()</td></tr>
<tr class="memdesc:aad09b58521217893f8f6bb076ade261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns library version.  <a href="namespacesopt.html#aad09b58521217893f8f6bb076ade261b">More...</a><br /></td></tr>
<tr class="separator:aad09b58521217893f8f6bb076ade261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e58ea24374aec8759a251b307a0af4"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; uint8_t, uint8_t, uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a67e58ea24374aec8759a251b307a0af4">version_tuple</a> ()</td></tr>
<tr class="memdesc:a67e58ea24374aec8759a251b307a0af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns library version.  <a href="namespacesopt.html#a67e58ea24374aec8759a251b307a0af4">More...</a><br /></td></tr>
<tr class="separator:a67e58ea24374aec8759a251b307a0af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1029fa88c4dddd856802462d2121deb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ae1029fa88c4dddd856802462d2121deb">gitref</a> ()</td></tr>
<tr class="memdesc:ae1029fa88c4dddd856802462d2121deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns library git reference, if known.  <a href="namespacesopt.html#ae1029fa88c4dddd856802462d2121deb">More...</a><br /></td></tr>
<tr class="separator:ae1029fa88c4dddd856802462d2121deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d9972b630fd6d0e88a914eb3aaaeda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a94d9972b630fd6d0e88a914eb3aaaeda">default_logging_level</a> ()</td></tr>
<tr class="memdesc:a94d9972b630fd6d0e88a914eb3aaaeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default logging level.  <a href="namespacesopt.html#a94d9972b630fd6d0e88a914eb3aaaeda">More...</a><br /></td></tr>
<tr class="separator:a94d9972b630fd6d0e88a914eb3aaaeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a92230a7a1fea0033bf12c848c2b8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a7d4a92230a7a1fea0033bf12c848c2b8">default_logger_name</a> ()</td></tr>
<tr class="memdesc:a7d4a92230a7a1fea0033bf12c848c2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default logger name.  <a href="namespacesopt.html#a7d4a92230a7a1fea0033bf12c848c2b8">More...</a><br /></td></tr>
<tr class="separator:a7d4a92230a7a1fea0033bf12c848c2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f7fdbcc2c8d7cdde37b39c2a14ddbb"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ad1f7fdbcc2c8d7cdde37b39c2a14ddbb">number_of_threads_in_tests</a> ()</td></tr>
<tr class="memdesc:ad1f7fdbcc2c8d7cdde37b39c2a14ddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads used during testing.  <a href="namespacesopt.html#ad1f7fdbcc2c8d7cdde37b39c2a14ddbb">More...</a><br /></td></tr>
<tr class="separator:ad1f7fdbcc2c8d7cdde37b39c2a14ddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b8391ddefe157e732bebe05696170e"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR &gt; </td></tr>
<tr class="memitem:a27b8391ddefe157e732bebe05696170e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a27b8391ddefe157e732bebe05696170e">linear_transform</a> (<a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;direct, <a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;indirect, std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;sizes={{1, 1, 0}})</td></tr>
<tr class="separator:a27b8391ddefe157e732bebe05696170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424b3b158a6f6c45c97eb244c688b429"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR &gt; </td></tr>
<tr class="memitem:a424b3b158a6f6c45c97eb244c688b429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a424b3b158a6f6c45c97eb244c688b429">linear_transform</a> (<a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;direct, std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;dsizes, <a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;indirect, std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;isizes)</td></tr>
<tr class="separator:a424b3b158a6f6c45c97eb244c688b429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ca3f91c20ceee3bb34066eda6824b8"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR &gt; </td></tr>
<tr class="memitem:a74ca3f91c20ceee3bb34066eda6824b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a74ca3f91c20ceee3bb34066eda6824b8">linear_transform</a> (<a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt; &amp;passthrough)</td></tr>
<tr class="memdesc:a74ca3f91c20ceee3bb34066eda6824b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience no-op function.  <a href="namespacesopt.html#a74ca3f91c20ceee3bb34066eda6824b8">More...</a><br /></td></tr>
<tr class="separator:a74ca3f91c20ceee3bb34066eda6824b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99abe8892d0073763dedb050b95dd3"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR &gt; </td></tr>
<tr class="memitem:a5d99abe8892d0073763dedb050b95dd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a5d99abe8892d0073763dedb050b95dd3">linear_transform</a> (<a class="el" href="classsopt_1_1details_1_1WrapFunction.html">details::WrapFunction</a>&lt; VECTOR &gt; const &amp;direct, <a class="el" href="classsopt_1_1details_1_1WrapFunction.html">details::WrapFunction</a>&lt; VECTOR &gt; const &amp;adjoint)</td></tr>
<tr class="memdesc:a5d99abe8892d0073763dedb050b95dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linear transform from a pair of wrappers.  <a href="namespacesopt.html#a5d99abe8892d0073763dedb050b95dd3">More...</a><br /></td></tr>
<tr class="separator:a5d99abe8892d0073763dedb050b95dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09baebf7a38995a5fde7f7b4130ddcbe"><td class="memTemplParams" colspan="2">template&lt;typename DERIVED &gt; </td></tr>
<tr class="memitem:a09baebf7a38995a5fde7f7b4130ddcbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">DERIVED::Scalar</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a09baebf7a38995a5fde7f7b4130ddcbe">linear_transform</a> (Eigen::MatrixBase&lt; DERIVED &gt; const &amp;A)</td></tr>
<tr class="memdesc:a09baebf7a38995a5fde7f7b4130ddcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to creates a function operator.  <a href="namespacesopt.html#a09baebf7a38995a5fde7f7b4130ddcbe">More...</a><br /></td></tr>
<tr class="separator:a09baebf7a38995a5fde7f7b4130ddcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf425c6640b07e4b2718d0a0db4c9cdd"><td class="memTemplParams" colspan="2">template&lt;typename SCALAR &gt; </td></tr>
<tr class="memitem:abf425c6640b07e4b2718d0a0db4c9cdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; SCALAR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#abf425c6640b07e4b2718d0a0db4c9cdd">linear_transform_identity</a> ()</td></tr>
<tr class="memdesc:abf425c6640b07e4b2718d0a0db4c9cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a linear transform that's just the identity.  <a href="namespacesopt.html#abf425c6640b07e4b2718d0a0db4c9cdd">More...</a><br /></td></tr>
<tr class="separator:abf425c6640b07e4b2718d0a0db4c9cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b0c108ec581a5b5f0c39276aefad8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a239b0c108ec581a5b5f0c39276aefad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a239b0c108ec581a5b5f0c39276aefad8">standard_deviation</a> (Eigen::ArrayBase&lt; T &gt; const &amp;x)</td></tr>
<tr class="memdesc:a239b0c108ec581a5b5f0c39276aefad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the standard deviation of a vector.  <a href="namespacesopt.html#a239b0c108ec581a5b5f0c39276aefad8">More...</a><br /></td></tr>
<tr class="separator:a239b0c108ec581a5b5f0c39276aefad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009292a23363f1e290a92ce6a2786065"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a009292a23363f1e290a92ce6a2786065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a009292a23363f1e290a92ce6a2786065">standard_deviation</a> (Eigen::MatrixBase&lt; T &gt; const &amp;x)</td></tr>
<tr class="memdesc:a009292a23363f1e290a92ce6a2786065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the standard deviation of a vector.  <a href="namespacesopt.html#a009292a23363f1e290a92ce6a2786065">More...</a><br /></td></tr>
<tr class="separator:a009292a23363f1e290a92ce6a2786065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6494afff8ee7f1196ff67ce646359d3e"><td class="memTemplParams" colspan="2">template&lt;typename SCALAR &gt; </td></tr>
<tr class="memitem:a6494afff8ee7f1196ff67ce646359d3e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; SCALAR &gt;::value or <a class="el" href="structsopt_1_1is__complex.html">is_complex</a>&lt; SCALAR &gt;::value, SCALAR &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a6494afff8ee7f1196ff67ce646359d3e">soft_threshhold</a> (SCALAR const &amp;x, typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; SCALAR &gt;::type const &amp;threshhold)</td></tr>
<tr class="memdesc:a6494afff8ee7f1196ff67ce646359d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">abs(x) &lt; threshhold ? 0: x - sgn(x) * threshhold  <a href="namespacesopt.html#a6494afff8ee7f1196ff67ce646359d3e">More...</a><br /></td></tr>
<tr class="separator:a6494afff8ee7f1196ff67ce646359d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430768559bd58eab9a93942fb99d1918"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a430768559bd58eab9a93942fb99d1918"><td class="memTemplItemLeft" align="right" valign="top">Eigen::CwiseUnaryOp&lt; const <a class="el" href="classsopt_1_1details_1_1ProjectPositiveQuadrant.html">details::ProjectPositiveQuadrant</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a430768559bd58eab9a93942fb99d1918">positive_quadrant</a> (Eigen::DenseBase&lt; T &gt; const &amp;input)</td></tr>
<tr class="memdesc:a430768559bd58eab9a93942fb99d1918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression to create projection onto positive quadrant.  <a href="namespacesopt.html#a430768559bd58eab9a93942fb99d1918">More...</a><br /></td></tr>
<tr class="separator:a430768559bd58eab9a93942fb99d1918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02ea9b606e6a1eef171de3447c77bc1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac02ea9b606e6a1eef171de3447c77bc1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::CwiseUnaryOp&lt; const <a class="el" href="namespacesopt_1_1details.html#a9b2c8778a2d73aff0499c9f899fe16df">details::SoftThreshhold</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ac02ea9b606e6a1eef171de3447c77bc1">soft_threshhold</a> (Eigen::DenseBase&lt; T &gt; const &amp;input, typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;::type const &amp;threshhold)</td></tr>
<tr class="memdesc:ac02ea9b606e6a1eef171de3447c77bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression to create soft-threshhold.  <a href="namespacesopt.html#ac02ea9b606e6a1eef171de3447c77bc1">More...</a><br /></td></tr>
<tr class="separator:ac02ea9b606e6a1eef171de3447c77bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3047abf694788f24705a1c656a250510"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a3047abf694788f24705a1c656a250510"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::value and std::is_arithmetic&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a> &gt;::value, Eigen::CwiseBinaryOp&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>(*)(typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;, typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a> const &amp;), const T0, const T1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a3047abf694788f24705a1c656a250510">soft_threshhold</a> (Eigen::DenseBase&lt; T0 &gt; const &amp;input, Eigen::DenseBase&lt; T1 &gt; const &amp;threshhold)</td></tr>
<tr class="memdesc:a3047abf694788f24705a1c656a250510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression to create soft-threshhold with multiple parameters.  <a href="namespacesopt.html#a3047abf694788f24705a1c656a250510">More...</a><br /></td></tr>
<tr class="separator:a3047abf694788f24705a1c656a250510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14309c45de330f8915e1ffd75fa8164"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:aa14309c45de330f8915e1ffd75fa8164"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structsopt_1_1is__complex.html">is_complex</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::value and std::is_arithmetic&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a> &gt;::value, Eigen::CwiseBinaryOp&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>(*)(typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;, typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;), const T0, decltype(std::declval&lt; const T1 &gt;).template cast&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;))&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#aa14309c45de330f8915e1ffd75fa8164">soft_threshhold</a> (Eigen::DenseBase&lt; T0 &gt; const &amp;input, Eigen::DenseBase&lt; T1 &gt; const &amp;threshhold)</td></tr>
<tr class="memdesc:aa14309c45de330f8915e1ffd75fa8164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression to create soft-threshhold with multiple parameters.  <a href="namespacesopt.html#aa14309c45de330f8915e1ffd75fa8164">More...</a><br /></td></tr>
<tr class="separator:aa14309c45de330f8915e1ffd75fa8164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992ab663c3f521cad1deff62844c4cc"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:ad992ab663c3f521cad1deff62844c4cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ad992ab663c3f521cad1deff62844c4cc">l1_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input, Eigen::ArrayBase&lt; T1 &gt; const &amp;weights)</td></tr>
<tr class="memdesc:ad992ab663c3f521cad1deff62844c4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L1 norm.  <a href="namespacesopt.html#ad992ab663c3f521cad1deff62844c4cc">More...</a><br /></td></tr>
<tr class="separator:ad992ab663c3f521cad1deff62844c4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db42dd287d02a4ff3ce6b7fa2f40857"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a2db42dd287d02a4ff3ce6b7fa2f40857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a2db42dd287d02a4ff3ce6b7fa2f40857">l1_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input, Eigen::MatrixBase&lt; T1 &gt; const &amp;weight)</td></tr>
<tr class="memdesc:a2db42dd287d02a4ff3ce6b7fa2f40857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L1 norm.  <a href="namespacesopt.html#a2db42dd287d02a4ff3ce6b7fa2f40857">More...</a><br /></td></tr>
<tr class="separator:a2db42dd287d02a4ff3ce6b7fa2f40857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f62b39e20496c485d78f97f9afa3e4"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:aa8f62b39e20496c485d78f97f9afa3e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#aa8f62b39e20496c485d78f97f9afa3e4">l1_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:aa8f62b39e20496c485d78f97f9afa3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes L1 norm.  <a href="namespacesopt.html#aa8f62b39e20496c485d78f97f9afa3e4">More...</a><br /></td></tr>
<tr class="separator:aa8f62b39e20496c485d78f97f9afa3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dac30fa2304a47833ce101737cebdbb"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:a5dac30fa2304a47833ce101737cebdbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a5dac30fa2304a47833ce101737cebdbb">l1_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:a5dac30fa2304a47833ce101737cebdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes L1 norm.  <a href="namespacesopt.html#a5dac30fa2304a47833ce101737cebdbb">More...</a><br /></td></tr>
<tr class="separator:a5dac30fa2304a47833ce101737cebdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78479408b10b1fa67e712247d4eefec"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:ae78479408b10b1fa67e712247d4eefec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ae78479408b10b1fa67e712247d4eefec">l2_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input, Eigen::ArrayBase&lt; T1 &gt; const &amp;weights)</td></tr>
<tr class="memdesc:ae78479408b10b1fa67e712247d4eefec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L2 norm.  <a href="namespacesopt.html#ae78479408b10b1fa67e712247d4eefec">More...</a><br /></td></tr>
<tr class="separator:ae78479408b10b1fa67e712247d4eefec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c3c1377f0345d2d3a5e5e16ae824e4"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a57c3c1377f0345d2d3a5e5e16ae824e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a57c3c1377f0345d2d3a5e5e16ae824e4">l2_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input, Eigen::MatrixBase&lt; T1 &gt; const &amp;weights)</td></tr>
<tr class="memdesc:a57c3c1377f0345d2d3a5e5e16ae824e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L2 norm.  <a href="namespacesopt.html#a57c3c1377f0345d2d3a5e5e16ae824e4">More...</a><br /></td></tr>
<tr class="separator:a57c3c1377f0345d2d3a5e5e16ae824e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae7c4b4b28cf09cb81be6bdc78d2acd"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:aaae7c4b4b28cf09cb81be6bdc78d2acd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#aaae7c4b4b28cf09cb81be6bdc78d2acd">l2_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:aaae7c4b4b28cf09cb81be6bdc78d2acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L2 norm.  <a href="namespacesopt.html#aaae7c4b4b28cf09cb81be6bdc78d2acd">More...</a><br /></td></tr>
<tr class="separator:aaae7c4b4b28cf09cb81be6bdc78d2acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e68fec339ce3ea64dd578483c1a19"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:acc5e68fec339ce3ea64dd578483c1a19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">l2_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:acc5e68fec339ce3ea64dd578483c1a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted L2 norm.  <a href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">More...</a><br /></td></tr>
<tr class="separator:acc5e68fec339ce3ea64dd578483c1a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f08c74e9b2cac9f30e52c2c6bdbd0f5"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a1f08c74e9b2cac9f30e52c2c6bdbd0f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a1f08c74e9b2cac9f30e52c2c6bdbd0f5">tv_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input, Eigen::ArrayBase&lt; T1 &gt; const &amp;weights)</td></tr>
<tr class="memdesc:a1f08c74e9b2cac9f30e52c2c6bdbd0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted TV norm.  <a href="namespacesopt.html#a1f08c74e9b2cac9f30e52c2c6bdbd0f5">More...</a><br /></td></tr>
<tr class="separator:a1f08c74e9b2cac9f30e52c2c6bdbd0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7db0a39348c31cdb1475fbeb26c84"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:ae0a7db0a39348c31cdb1475fbeb26c84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ae0a7db0a39348c31cdb1475fbeb26c84">tv_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input, Eigen::MatrixBase&lt; T1 &gt; const &amp;weights)</td></tr>
<tr class="memdesc:ae0a7db0a39348c31cdb1475fbeb26c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted TV norm.  <a href="namespacesopt.html#ae0a7db0a39348c31cdb1475fbeb26c84">More...</a><br /></td></tr>
<tr class="separator:ae0a7db0a39348c31cdb1475fbeb26c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967222064d29c760e307ece5da21168"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:a1967222064d29c760e307ece5da21168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a1967222064d29c760e307ece5da21168">tv_norm</a> (Eigen::ArrayBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:a1967222064d29c760e307ece5da21168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted tv norm.  <a href="namespacesopt.html#a1967222064d29c760e307ece5da21168">More...</a><br /></td></tr>
<tr class="separator:a1967222064d29c760e307ece5da21168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b301acf3c109ea862ff9e563d2a164"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:a96b301acf3c109ea862ff9e563d2a164"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">tv_norm</a> (Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</td></tr>
<tr class="memdesc:a96b301acf3c109ea862ff9e563d2a164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weighted TV norm.  <a href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">More...</a><br /></td></tr>
<tr class="separator:a96b301acf3c109ea862ff9e563d2a164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e13505f1425dd1bfa7e33b81f0729c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a41e13505f1425dd1bfa7e33b81f0729c">imageToFloat</a> (<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt; <a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a> &gt; const &amp;image)</td></tr>
<tr class="separator:a41e13505f1425dd1bfa7e33b81f0729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681e8b650f3797972d9e4b1c27cf8be3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a681e8b650f3797972d9e4b1c27cf8be3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a681e8b650f3797972d9e4b1c27cf8be3">imageToFloat</a> (<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt; T &gt; const &amp;image)</td></tr>
<tr class="separator:a681e8b650f3797972d9e4b1c27cf8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac714d2f3ce2bd0e93bd2d32eccefcb37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt; <a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ac714d2f3ce2bd0e93bd2d32eccefcb37">floatToImage</a> (std::vector&lt; float &gt; const &amp;float_image)</td></tr>
<tr class="separator:ac714d2f3ce2bd0e93bd2d32eccefcb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b3045c6210eedfab02fd8faf71c18a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57b3045c6210eedfab02fd8faf71c18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a57b3045c6210eedfab02fd8faf71c18a">linear_transform</a> (<a class="el" href="classsopt_1_1Sampling.html">Sampling</a> const &amp;sampling)</td></tr>
<tr class="memdesc:a57b3045c6210eedfab02fd8faf71c18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns linear transform version of this object.  <a href="namespacesopt.html#a57b3045c6210eedfab02fd8faf71c18a">More...</a><br /></td></tr>
<tr class="separator:a57b3045c6210eedfab02fd8faf71c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b77806f4ddf6e970dbb6b03613e39f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43b77806f4ddf6e970dbb6b03613e39f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a43b77806f4ddf6e970dbb6b03613e39f">linear_transform</a> (<a class="el" href="classsopt_1_1wavelets_1_1Wavelet.html">wavelets::Wavelet</a> const &amp;wavelet)</td></tr>
<tr class="memdesc:a43b77806f4ddf6e970dbb6b03613e39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin linear-transform wrapper around 1d wavelets.  <a href="namespacesopt.html#a43b77806f4ddf6e970dbb6b03613e39f">More...</a><br /></td></tr>
<tr class="separator:a43b77806f4ddf6e970dbb6b03613e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3985419d8cc35852bff69d403aef8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e3985419d8cc35852bff69d403aef8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a5e3985419d8cc35852bff69d403aef8a">linear_transform</a> (<a class="el" href="classsopt_1_1wavelets_1_1SARA.html">wavelets::SARA</a> const &amp;sara)</td></tr>
<tr class="memdesc:a5e3985419d8cc35852bff69d403aef8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin linear-transform wrapper around 1d sara operator.  <a href="namespacesopt.html#a5e3985419d8cc35852bff69d403aef8a">More...</a><br /></td></tr>
<tr class="separator:a5e3985419d8cc35852bff69d403aef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a54108659a468d1a4c2177d7a88b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d9a54108659a468d1a4c2177d7a88b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a2d9a54108659a468d1a4c2177d7a88b0">linear_transform</a> (<a class="el" href="classsopt_1_1wavelets_1_1Wavelet.html">wavelets::Wavelet</a> const &amp;wavelet, <a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a> <a class="el" href="credible__region_8cc.html#a1cc6c6d663c5f0c6cbd63b69ca306721">rows</a>, <a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a> <a class="el" href="credible__region_8cc.html#a4f8d1cebdd1d0572b0f5ff58464b9216">cols</a>=1)</td></tr>
<tr class="memdesc:a2d9a54108659a468d1a4c2177d7a88b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin linear-transform wrapper around 2d wavelets.  <a href="namespacesopt.html#a2d9a54108659a468d1a4c2177d7a88b0">More...</a><br /></td></tr>
<tr class="separator:a2d9a54108659a468d1a4c2177d7a88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c445e577476358820c5cef07f4e3998"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c445e577476358820c5cef07f4e3998"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a9c445e577476358820c5cef07f4e3998">linear_transform</a> (<a class="el" href="classsopt_1_1wavelets_1_1SARA.html">wavelets::SARA</a> const &amp;sara, <a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a> <a class="el" href="credible__region_8cc.html#a1cc6c6d663c5f0c6cbd63b69ca306721">rows</a>, <a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a> <a class="el" href="credible__region_8cc.html#a4f8d1cebdd1d0572b0f5ff58464b9216">cols</a>=1)</td></tr>
<tr class="memdesc:a9c445e577476358820c5cef07f4e3998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin linear-transform wrapper around 2d wavelets.  <a href="namespacesopt.html#a9c445e577476358820c5cef07f4e3998">More...</a><br /></td></tr>
<tr class="separator:a9c445e577476358820c5cef07f4e3998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f816b885c3c1e6e59760df6436c8111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f816b885c3c1e6e59760df6436c8111"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a1f816b885c3c1e6e59760df6436c8111">direct_transform</a> (void *out, void *in, void **data)</td></tr>
<tr class="separator:a1f816b885c3c1e6e59760df6436c8111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44810fe3a30c81d0c9c5c91dd60011f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44810fe3a30c81d0c9c5c91dd60011f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a44810fe3a30c81d0c9c5c91dd60011f8">adjoint_transform</a> (void *out, void *in, void **data)</td></tr>
<tr class="separator:a44810fe3a30c81d0c9c5c91dd60011f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a82628fe55e720accd252a72c7337c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83a82628fe55e720accd252a72c7337c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a83a82628fe55e720accd252a72c7337c">target</a> (<a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;sampling, <a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;image)</td></tr>
<tr class="separator:a83a82628fe55e720accd252a72c7337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fbfa0f1f262d124020ccaf5e6cb573"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7fbfa0f1f262d124020ccaf5e6cb573"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#ad7fbfa0f1f262d124020ccaf5e6cb573">sigma</a> (<a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;sampling, <a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;image)</td></tr>
<tr class="separator:ad7fbfa0f1f262d124020ccaf5e6cb573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a813b13ba02590f41062b84996e0d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename RANDOM &gt; </td></tr>
<tr class="memitem:a52a813b13ba02590f41062b84996e0d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a52a813b13ba02590f41062b84996e0d5">dirty</a> (<a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;sampling, <a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;image, RANDOM &amp;<a class="el" href="common__mpi__catch__main_8cc.html#afd7b13def75c5d7feb77ac1ea2df5d0b">mersenne</a>)</td></tr>
<tr class="separator:a52a813b13ba02590f41062b84996e0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f99e567f8ac05a0fe5e50fbfd215b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a974f99e567f8ac05a0fe5e50fbfd215b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesopt.html#a974f99e567f8ac05a0fe5e50fbfd215b">epsilon</a> (<a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;sampling, <a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;image)</td></tr>
<tr class="separator:a974f99e567f8ac05a0fe5e50fbfd215b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9de8d7c976f608fe47220203047b5cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de8d7c976f608fe47220203047b5cb8">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a9de8d7c976f608fe47220203047b5cb8">sopt::Array</a> = typedef Eigen::Array&lt;T, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 1-dimensional list of elements of given type. </p>
<p>Operates coefficient-wise, not matrix-vector-wise </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00034">34</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="acc375c693a8c32c2a954d17a7773b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc375c693a8c32c2a954d17a7773b7f8">&#9670;&nbsp;</a></span>ConvergenceFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALAR  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#acc375c693a8c32c2a954d17a7773b7f8">sopt::ConvergenceFunction</a> = typedef std::function&lt;bool(<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;SCALAR&gt; const &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typical function signature for convergence. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00052">52</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a7d7971e5566e597eb907614917e30c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7971e5566e597eb907614917e30c78">&#9670;&nbsp;</a></span>Image</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a> = typedef Eigen::Array&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2-dimensional list of elements of given type. </p>
<p>Operates coefficient-wise, not matrix-vector-wise </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00039">39</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="adedb6b3e862bd2968bf3026599121630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedb6b3e862bd2968bf3026599121630">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#adedb6b3e862bd2968bf3026599121630">sopt::Matrix</a> = typedef Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of a given type. </p>
<p>Operates as mathematical matrix. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00029">29</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="aa4353f012100677172534381f2801fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4353f012100677172534381f2801fa9">&#9670;&nbsp;</a></span>OperatorFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR  = Vector&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">sopt::OperatorFunction</a> = typedef std::function&lt;void(VECTOR &amp;, VECTOR const &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typical function out = A*x. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00043">43</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="acbf84f975b1aa24c2925150488215df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf84f975b1aa24c2925150488215df2">&#9670;&nbsp;</a></span>ProximalFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALAR  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#acbf84f975b1aa24c2925150488215df2">sopt::ProximalFunction</a> = typedef std::function&lt;void(<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;SCALAR&gt; &amp;output, typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;SCALAR&gt;::type const weight, <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;SCALAR&gt; const &amp;input)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typical function signature for calls to proximal. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00047">47</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a7ee75936aaae93251b12abb77c3e02aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee75936aaae93251b12abb77c3e02aa">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">sopt::real_type</a> = typedef <a class="el" href="classsopt_1_1details_1_1underlying__value__type.html">details::underlying_value_type</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets to the underlying real type. </p>

<p class="definition">Definition at line <a class="el" href="real__type_8h_source.html#l00056">56</a> of file <a class="el" href="real__type_8h_source.html">real_type.h</a>.</p>

</div>
</div>
<a id="ad24bc0cbf4f1391b3d1440213329d13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24bc0cbf4f1391b3d1440213329d13f">&#9670;&nbsp;</a></span>t_complex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">sopt::t_complex</a> = typedef std::complex&lt;<a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root of the type hierarchy for (real) complex numbers. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00019">19</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a47796df8f5f6bbffc226292ef1ca8196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47796df8f5f6bbffc226292ef1ca8196">&#9670;&nbsp;</a></span>t_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">sopt::t_int</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root of the type hierarchy for signed integers. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00013">13</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a71bfb8f70b432862d3d654b9dcff77cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bfb8f70b432862d3d654b9dcff77cc">&#9670;&nbsp;</a></span>t_real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">sopt::t_real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root of the type hierarchy for real numbers. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00017">17</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a7237c0991f6ec8c2bbdab8929b564964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7237c0991f6ec8c2bbdab8929b564964">&#9670;&nbsp;</a></span>t_uint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">sopt::t_uint</a> = typedef size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root of the type hierarchy for unsigned integers. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00015">15</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="ac4dd3feebe1bf49ebd44d72b05064c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dd3feebe1bf49ebd44d72b05064c19">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = t_real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a> = typedef <a class="el" href="tf__inpainting_8cc.html#ab86a00c212fb2233871e057014ded6a6">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of a given type. </p>
<p>Operates as mathematical vector. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00024">24</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a44810fe3a30c81d0c9c5c91dd60011f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44810fe3a30c81d0c9c5c91dd60011f8">&#9670;&nbsp;</a></span>adjoint_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sopt::adjoint_transform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cdata_8h_source.html#l00027">27</a> of file <a class="el" href="cdata_8h_source.html">cdata.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                                         {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  CData&lt;T&gt; <span class="keyword">const</span> &amp;cdata = *(CData&lt;T&gt; *)data;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keyword">using</span> <a class="code" href="bisection__method_8cc.html#a150b8eda2681eca0377a440541891747">t_Vector</a> = Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <a class="code" href="bisection__method_8cc.html#a150b8eda2681eca0377a440541891747">t_Vector</a> <span class="keyword">const</span> eval = cdata.transform.adjoint() * t_Vector::Map((T *)in, cdata.nout);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  ++(((CData&lt;T&gt; *)data)-&gt;adjoint_calls);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  t_Vector::Map((T *)out, cdata.nin) = eval;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div>
<div class="ttc" id="abisection__method_8cc_html_a150b8eda2681eca0377a440541891747"><div class="ttname"><a href="bisection__method_8cc.html#a150b8eda2681eca0377a440541891747">t_Vector</a></div><div class="ttdeci">sopt::Vector&lt; Scalar &gt; t_Vector</div><div class="ttdef"><b>Definition:</b> <a href="bisection__method_8cc_source.html#l00010">bisection_method.cc:10</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="linear__transform_8h_source.html#l00079">sopt::LinearTransform&lt; VECTOR &gt;::adjoint()</a>, <a class="el" href="cdata_8h_source.html#l00013">sopt::CData&lt; T &gt;::nin</a>, <a class="el" href="cdata_8h_source.html#l00013">sopt::CData&lt; T &gt;::nout</a>, and <a class="el" href="cdata_8h_source.html#l00014">sopt::CData&lt; T &gt;::transform</a>.</p>

</div>
</div>
<a id="a7574fac5dcbb3569bad1e0d08a553406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7574fac5dcbb3569bad1e0d08a553406">&#9670;&nbsp;</a></span>bisection_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a>, K &gt;::value, K &gt;::type sopt::bisection_method </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>function_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; K(K)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesopt.html#a71bfb8f70b432862d3d654b9dcff77cc">t_real</a> &amp;&#160;</td>
          <td class="paramname"><em>rel_convergence</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find root to a function within an interval. </p>

<p class="definition">Definition at line <a class="el" href="bisection__method_8h_source.html#l00018">18</a> of file <a class="el" href="bisection__method_8h_source.html">bisection_method.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                                   {</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> lower_eta = <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> upper_eta = <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> relative_difference = 1;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> eta = (<a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a> + <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>) * 0.5;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <a class="code" href="logging_8h.html#a4a497e6b273bf510772846ac52cef095">SOPT_LOW_LOG</a>(<span class="stringliteral">&quot;Starting bisection method over x ∈ [{}, {}], to estimate f(x) = {}&quot;</span>, <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>, <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>,</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;               function_value);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> estimate = [&amp;](<span class="keyword">const</span> K &amp;x) { <span class="keywordflow">return</span> func(x) - function_value; };</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="keyword">const</span> <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> eb = estimate(<a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keyword">const</span> <a class="code" href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a> ea = estimate(<a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="keywordflow">if</span> (eb == 0) <span class="keywordflow">return</span> <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keywordflow">if</span> (ea == 0) <span class="keywordflow">return</span> <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="keywordflow">if</span> ((ea &gt; 0 and eb &gt; 0) or (ea &lt; 0 and eb &lt; 0))</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="exception_8h.html#a57974308768f9fafc7107b626a394f4f">SOPT_THROW</a>(<span class="stringliteral">&quot;f(a) = &quot;</span> &lt;&lt; ea &lt;&lt; <span class="stringliteral">&quot; and f(b) = &quot;</span> &lt;&lt; eb</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                         &lt;&lt; <span class="stringliteral">&quot; have the wrong sign.&quot;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                            <span class="stringliteral">&quot;Where a = &quot;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                         &lt;&lt; <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a> &lt;&lt; <span class="stringliteral">&quot; and b = &quot;</span> &lt;&lt; <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                         &lt;&lt; <span class="stringliteral">&quot; Bisection Method not applicable for &quot;</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                            <span class="stringliteral">&quot;this function.&quot;</span>);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> sign = [&amp;](<span class="keyword">const</span> K &amp;x) { <span class="keywordflow">return</span> (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0); };</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// SOPT_LOW_LOG(&quot;Convergence when: |f((a+b)/2) -f(x)| &lt; {} or |a - b| &lt; {}&quot;, rel_convergence,</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="comment">//              rel_convergence);</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">while</span> (rel_convergence &lt; relative_difference or</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;         std::abs(upper_eta - lower_eta) &gt; rel_convergence) {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">if</span> (upper_eta == lower_eta) <a class="code" href="exception_8h.html#a57974308768f9fafc7107b626a394f4f">SOPT_THROW</a>(<span class="stringliteral">&quot;a == b, something is wrong.&quot;</span>);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    eta = (lower_eta + upper_eta) * 0.5;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> function_est = estimate(eta);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">if</span> (sign(estimate(lower_eta)) == sign(estimate(eta)))</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;      lower_eta = eta;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      upper_eta = eta;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    relative_difference = std::abs(function_est);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    assert(!(estimate(lower_eta) &gt; 0 and estimate(upper_eta) &gt; 0) and</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;           !(estimate(lower_eta) &lt; 0 and estimate(upper_eta) &lt; 0));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="comment">//   SOPT_LOW_LOG(&quot;|f(x_0) - f(x)| = {}, x = {}, [{}, {}]&quot;, relative_difference, eta, lower_eta,</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">//                upper_eta);</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">return</span> eta;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div>
<div class="ttc" id="abisection__method_8cc_html_a63a56f8266f9d4e2b7904199812311c4"><div class="ttname"><a href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a></div><div class="ttdeci">constexpr Scalar b</div><div class="ttdef"><b>Definition:</b> <a href="bisection__method_8cc_source.html#l00014">bisection_method.cc:14</a></div></div>
<div class="ttc" id="abisection__method_8cc_html_abe0def96c0a846f46d6fe7c115ff2a7f"><div class="ttname"><a href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a></div><div class="ttdeci">constexpr Scalar a</div><div class="ttdef"><b>Definition:</b> <a href="bisection__method_8cc_source.html#l00013">bisection_method.cc:13</a></div></div>
<div class="ttc" id="aexception_8h_html_a57974308768f9fafc7107b626a394f4f"><div class="ttname"><a href="exception_8h.html#a57974308768f9fafc7107b626a394f4f">SOPT_THROW</a></div><div class="ttdeci">#define SOPT_THROW(MSG)</div><div class="ttdef"><b>Definition:</b> <a href="exception_8h_source.html#l00046">exception.h:46</a></div></div>
<div class="ttc" id="aforward__backward_8cc_html_adf3dc3fe16f041e337211cca9c8882dc"><div class="ttname"><a href="forward__backward_8cc.html#adf3dc3fe16f041e337211cca9c8882dc">t_real</a></div><div class="ttdeci">sopt::t_real t_real</div><div class="ttdef"><b>Definition:</b> <a href="forward__backward_8cc_source.html#l00028">forward_backward.cc:28</a></div></div>
<div class="ttc" id="alogging_8h_html_a4a497e6b273bf510772846ac52cef095"><div class="ttname"><a href="logging_8h.html#a4a497e6b273bf510772846ac52cef095">SOPT_LOW_LOG</a></div><div class="ttdeci">#define SOPT_LOW_LOG(...)</div><div class="ttdoc">Low priority message.</div><div class="ttdef"><b>Definition:</b> <a href="logging_8h_source.html#l00227">logging.h:227</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="bisection__method_8cc_source.html#l00013">a</a>, <a class="el" href="bisection__method_8cc_source.html#l00014">b</a>, <a class="el" href="logging_8h_source.html#l00227">SOPT_LOW_LOG</a>, and <a class="el" href="exception_8h_source.html#l00046">SOPT_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="credible__region_8h_source.html#l00075">sopt::credible_region::find_credible_interval()</a>, and <a class="el" href="bisection__method_8cc_source.html#l00016">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a5e8a990d75711b892ac8bf2f030d8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8a990d75711b892ac8bf2f030d8c1e">&#9670;&nbsp;</a></span>chained_operators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt;T0&gt; sopt::chained_operators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="chained__operators_8h_source.html#l00012">12</a> of file <a class="el" href="chained__operators_8h_source.html">chained_operators.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>...(args) == 0) <span class="keywordflow">return</span> arg0;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  std::vector&lt;OperatorFunction&lt;T0&gt;&gt; <span class="keyword">const</span> funcs = {arg0, args...};</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  <span class="keyword">const</span> std::shared_ptr&lt;T0&gt; buffer = std::make_shared&lt;T0&gt;();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  OperatorFunction&lt;T0&gt; result = [funcs, buffer](T0 &amp;output, T0 <span class="keyword">const</span> &amp;input) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="keyword">auto</span> first = funcs.rbegin();</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> last = funcs.rend();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="keywordflow">if</span> (funcs.size() == 1)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      (*first)(output, input);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (funcs.size() % 2 == 1)</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;      (*first)(output, input);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      (*first)(*buffer, input);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      first++;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;      (*first)(output, *buffer);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    }</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">for</span> (++first; first != last; first++) {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      (*first)(*buffer, output);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      first++;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      (*first)(output, *buffer);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  };</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="chained__operators_8cc_source.html#l00008">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a7d4a92230a7a1fea0033bf12c848c2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a92230a7a1fea0033bf12c848c2b8">&#9670;&nbsp;</a></span>default_logger_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sopt::default_logger_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default logger name. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00047">47</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;@SOPT_LOGGER_NAME@&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94d9972b630fd6d0e88a914eb3aaaeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d9972b630fd6d0e88a914eb3aaaeda">&#9670;&nbsp;</a></span>default_logging_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sopt::default_logging_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default logging level. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00044">44</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;@SOPT_TEST_LOG_LEVEL@&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f816b885c3c1e6e59760df6436c8111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f816b885c3c1e6e59760df6436c8111">&#9670;&nbsp;</a></span>direct_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sopt::direct_transform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cdata_8h_source.html#l00019">19</a> of file <a class="el" href="cdata_8h_source.html">cdata.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                                        {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  CData&lt;T&gt; <span class="keyword">const</span> &amp;cdata = *(CData&lt;T&gt; *)data;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <span class="keyword">using</span> <a class="code" href="bisection__method_8cc.html#a150b8eda2681eca0377a440541891747">t_Vector</a> = Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <a class="code" href="bisection__method_8cc.html#a150b8eda2681eca0377a440541891747">t_Vector</a> <span class="keyword">const</span> eval = cdata.transform * t_Vector::Map((T *)in, cdata.nin);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  ++(((CData&lt;T&gt; *)data)-&gt;direct_calls);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  t_Vector::Map((T *)out, cdata.nout) = eval;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="cdata_8h_source.html#l00013">sopt::CData&lt; T &gt;::nin</a>, <a class="el" href="cdata_8h_source.html#l00013">sopt::CData&lt; T &gt;::nout</a>, and <a class="el" href="cdata_8h_source.html#l00014">sopt::CData&lt; T &gt;::transform</a>.</p>

</div>
</div>
<a id="a52a813b13ba02590f41062b84996e0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a813b13ba02590f41062b84996e0d5">&#9670;&nbsp;</a></span>dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename RANDOM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; sopt::dirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RANDOM &amp;&#160;</td>
          <td class="paramname"><em>mersenne</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inpainting_8h_source.html#l00025">25</a> of file <a class="el" href="inpainting_8h_source.html">inpainting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                  {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="comment">// values near the mean are the most likely</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="comment">// standard deviation affects the dispersion of generated values from the mean</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> y0 = <a class="code" href="namespacesopt.html#a83a82628fe55e720accd252a72c7337c">target</a>(sampling, image);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  std::normal_distribution&lt;&gt; gaussian_dist(0, <a class="code" href="namespacesopt.html#ad7fbfa0f1f262d124020ccaf5e6cb573">sigma</a>(sampling, image));</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;</a> y(y0.size());</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a> i = 0; i &lt; y0.size(); i++) y(i) = y0(i) + gaussian_dist(<a class="code" href="common__catch__main_8cc.html#afd7b13def75c5d7feb77ac1ea2df5d0b">mersenne</a>);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="keywordflow">return</span> y;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div>
<div class="ttc" id="acommon__catch__main_8cc_html_afd7b13def75c5d7feb77ac1ea2df5d0b"><div class="ttname"><a href="common__catch__main_8cc.html#afd7b13def75c5d7feb77ac1ea2df5d0b">mersenne</a></div><div class="ttdeci">std::unique_ptr&lt; std::mt19937_64 &gt; mersenne(new std::mt19937_64(0))</div></div>
<div class="ttc" id="anamespacesopt_html_a47796df8f5f6bbffc226292ef1ca8196"><div class="ttname"><a href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">sopt::t_int</a></div><div class="ttdeci">int t_int</div><div class="ttdoc">Root of the type hierarchy for signed integers.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00013">types.h:13</a></div></div>
<div class="ttc" id="anamespacesopt_html_a83a82628fe55e720accd252a72c7337c"><div class="ttname"><a href="namespacesopt.html#a83a82628fe55e720accd252a72c7337c">sopt::target</a></div><div class="ttdeci">Vector&lt; T &gt; target(sopt::LinearTransform&lt; Vector&lt; T &gt;&gt; const &amp;sampling, sopt::Image&lt; T &gt; const &amp;image)</div><div class="ttdef"><b>Definition:</b> <a href="inpainting_8h_source.html#l00012">inpainting.h:12</a></div></div>
<div class="ttc" id="anamespacesopt_html_ad7fbfa0f1f262d124020ccaf5e6cb573"><div class="ttname"><a href="namespacesopt.html#ad7fbfa0f1f262d124020ccaf5e6cb573">sopt::sigma</a></div><div class="ttdeci">real_type&lt; T &gt;::type sigma(sopt::LinearTransform&lt; Vector&lt; T &gt;&gt; const &amp;sampling, sopt::Image&lt; T &gt; const &amp;image)</div><div class="ttdef"><b>Definition:</b> <a href="inpainting_8h_source.html#l00017">inpainting.h:17</a></div></div>
<div class="ttc" id="atests_2inpainting_8cc_html_a47c194cae73625ab3a13b62e4234f46f"><div class="ttname"><a href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector</a></div><div class="ttdeci">sopt::Vector&lt; Scalar &gt; Vector</div><div class="ttdef"><b>Definition:</b> <a href="tests_2inpainting_8cc_source.html#l00028">inpainting.cc:28</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="common__catch__main_8cc.html#afd7b13def75c5d7feb77ac1ea2df5d0b">mersenne()</a>, <a class="el" href="inpainting_8h_source.html#l00017">sigma()</a>, and <a class="el" href="inpainting_8h_source.html#l00012">target()</a>.</p>

<p class="reference">Referenced by <a class="el" href="examples_2forward__backward_2inpainting_8cc_source.html#l00024">main()</a>.</p>

</div>
</div>
<a id="a974f99e567f8ac05a0fe5e50fbfd215b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974f99e567f8ac05a0fe5e50fbfd215b">&#9670;&nbsp;</a></span>epsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;T&gt;::type sopt::epsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inpainting_8h_source.html#l00038">38</a> of file <a class="el" href="inpainting_8h_source.html">inpainting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                                               {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> y0 = <a class="code" href="namespacesopt.html#a83a82628fe55e720accd252a72c7337c">target</a>(sampling, image);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> nmeasure = y0.size();</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">return</span> std::sqrt(nmeasure + 2 * std::sqrt(nmeasure)) * <a class="code" href="namespacesopt.html#ad7fbfa0f1f262d124020ccaf5e6cb573">sigma</a>(sampling, image);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="inpainting_8h_source.html#l00017">sigma()</a>, and <a class="el" href="inpainting_8h_source.html#l00012">target()</a>.</p>

<p class="reference">Referenced by <a class="el" href="benchmarks_2conjugate__gradient_8cc_source.html#l00021">function_cg()</a>, <a class="el" href="examples_2forward__backward_2inpainting_8cc_source.html#l00024">main()</a>, <a class="el" href="benchmarks_2conjugate__gradient_8cc_source.html#l00006">matrix_cg()</a>, and <a class="el" href="tests_2inpainting_8cc_source.html#l00032">TEST_CASE()</a>.</p>

</div>
</div>
<a id="ac714d2f3ce2bd0e93bd2d32eccefcb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac714d2f3ce2bd0e93bd2d32eccefcb37">&#9670;&nbsp;</a></span>floatToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt;<a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a>&gt; sopt::floatToImage </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; const &amp;&#160;</td>
          <td class="paramname"><em>float_image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="onnx__differentiable__func_8h_source.html#l00032">32</a> of file <a class="el" href="onnx__differentiable__func_8h_source.html">onnx_differentiable_func.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <a class="code" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector&lt;t_complex&gt;</a> image(float_image.size());</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; float_image.size(); i++)</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            image[i] = <a class="code" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a>(float_image[i], 0);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">return</span> image;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="ttc" id="anamespacesopt_html_ac4dd3feebe1bf49ebd44d72b05064c19"><div class="ttname"><a href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a></div><div class="ttdeci">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; Vector</div><div class="ttdoc">A vector of a given type.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00024">types.h:24</a></div></div>
<div class="ttc" id="anamespacesopt_html_ad24bc0cbf4f1391b3d1440213329d13f"><div class="ttname"><a href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">sopt::t_complex</a></div><div class="ttdeci">std::complex&lt; t_real &gt; t_complex</div><div class="ttdoc">Root of the type hierarchy for (real) complex numbers.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00019">types.h:19</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1029fa88c4dddd856802462d2121deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1029fa88c4dddd856802462d2121deb">&#9670;&nbsp;</a></span>gitref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sopt::gitref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns library git reference, if known. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00041">41</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;@SOPT_GITREF@&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a681e8b650f3797972d9e4b1c27cf8be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681e8b650f3797972d9e4b1c27cf8be3">&#9670;&nbsp;</a></span>imageToFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; sopt::imageToFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="onnx__differentiable__func_8h_source.html#l00022">22</a> of file <a class="el" href="onnx__differentiable__func_8h_source.html">onnx_differentiable_func.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    {</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        std::vector&lt;float&gt; float_image(image.size());</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; image.size(); i++)</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;            float_image[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(image[i]);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        }</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">return</span> float_image;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a41e13505f1425dd1bfa7e33b81f0729c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e13505f1425dd1bfa7e33b81f0729c">&#9670;&nbsp;</a></span>imageToFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; sopt::imageToFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">sopt::Vector</a>&lt; <a class="el" href="namespacesopt.html#ad24bc0cbf4f1391b3d1440213329d13f">t_complex</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="onnx__differentiable__func_8h_source.html#l00011">11</a> of file <a class="el" href="onnx__differentiable__func_8h_source.html">onnx_differentiable_func.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        std::vector&lt;float&gt; float_image(image.size());</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; image.size(); i++)</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;            float_image[i] = image[i].real();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        }</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">return</span> float_image;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="onnx__differentiable__func_8h_source.html#l00107">sopt::ONNXDifferentiableFunc&lt; SCALAR &gt;::function()</a>, and <a class="el" href="onnx__differentiable__func_8h_source.html#l00080">sopt::ONNXDifferentiableFunc&lt; SCALAR &gt;::gradient()</a>.</p>

</div>
</div>
<a id="aa8f62b39e20496c485d78f97f9afa3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f62b39e20496c485d78f97f9afa3e4">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l1_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes L1 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00129">129</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keywordflow">return</span> input.cwiseAbs().sum();</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad992ab663c3f521cad1deff62844c4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad992ab663c3f521cad1deff62844c4cc">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l1_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::ArrayBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L1 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00116">116</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keywordflow">if</span> (weights.size() == 1) <span class="keywordflow">return</span> input.cwiseAbs().sum() * std::abs(weights(0));</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="keywordflow">return</span> (input * weights).cwiseAbs().sum();</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="l1__non__diff__function_8h_source.html#l00053">sopt::algorithm::L1GProximal&lt; SCALAR &gt;::function()</a>, <a class="el" href="tf__non__diff__function_8h_source.html#l00049">sopt::algorithm::TFGProximal&lt; SCALAR &gt;::function()</a>, <a class="el" href="maths_8h_source.html#l00123">l1_norm()</a>, <a class="el" href="examples_2sdmm_2inpainting_8cc_source.html#l00023">main()</a>, <a class="el" href="l1__proximal_8h_source.html#l00149">sopt::proximal::L1TightFrame&lt; SCALAR &gt;::objective()</a>, <a class="el" href="maths_8cc_source.html#l00055">TEST_CASE()</a>, and <a class="el" href="objective__functions_8h_source.html#l00043">sopt::objective_functions::unconstrained_l1_regularisation()</a>.</p>

</div>
</div>
<a id="a5dac30fa2304a47833ce101737cebdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dac30fa2304a47833ce101737cebdbb">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l1_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes L1 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00134">134</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a5dac30fa2304a47833ce101737cebdbb">l1_norm</a>(input.array());</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_html_a5dac30fa2304a47833ce101737cebdbb"><div class="ttname"><a href="namespacesopt.html#a5dac30fa2304a47833ce101737cebdbb">sopt::l1_norm</a></div><div class="ttdeci">real_type&lt; typename T0::Scalar &gt;::type l1_norm(Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</div><div class="ttdoc">Computes L1 norm.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00134">maths.h:134</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00116">l1_norm()</a>.</p>

</div>
</div>
<a id="a2db42dd287d02a4ff3ce6b7fa2f40857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db42dd287d02a4ff3ce6b7fa2f40857">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l1_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L1 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00123">123</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a5dac30fa2304a47833ce101737cebdbb">l1_norm</a>(input.array(), weight.array());</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00116">l1_norm()</a>.</p>

</div>
</div>
<a id="aaae7c4b4b28cf09cb81be6bdc78d2acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae7c4b4b28cf09cb81be6bdc78d2acd">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L2 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00153">153</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="keyword">typename</span> T0::PlainObject w(1);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  w(0) = 1;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">l2_norm</a>(input, w);</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_html_acc5e68fec339ce3ea64dd578483c1a19"><div class="ttname"><a href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">sopt::l2_norm</a></div><div class="ttdeci">real_type&lt; typename T0::Scalar &gt;::type l2_norm(Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</div><div class="ttdoc">Computes weighted L2 norm.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00160">maths.h:160</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00140">l2_norm()</a>.</p>

</div>
</div>
<a id="ae78479408b10b1fa67e712247d4eefec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78479408b10b1fa67e712247d4eefec">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::ArrayBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L2 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00140">140</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordflow">if</span> (weights.size() == 1) <span class="keywordflow">return</span> input.matrix().stableNorm() * std::abs(weights(0));</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="keywordflow">return</span> (input * weights).matrix().stableNorm();</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="maths_8h_source.html#l00147">l2_norm()</a>, <a class="el" href="inpainting__credible__interval_8cc_source.html#l00025">main()</a>, <a class="el" href="serial__vs__parallel__padmm_8cc_source.html#l00023">TEST_CASE()</a>, and <a class="el" href="objective__functions_8h_source.html#l00035">sopt::objective_functions::unconstrained_regularisation()</a>.</p>

</div>
</div>
<a id="acc5e68fec339ce3ea64dd578483c1a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5e68fec339ce3ea64dd578483c1a19">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L2 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00160">160</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="keyword">typename</span> T0::PlainObject w(1);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  w(0) = 1;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">l2_norm</a>(input.derived().array(), w.array());</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00140">l2_norm()</a>.</p>

</div>
</div>
<a id="a57c3c1377f0345d2d3a5e5e16ae824e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c3c1377f0345d2d3a5e5e16ae824e4">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted L2 norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00147">147</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#acc5e68fec339ce3ea64dd578483c1a19">l2_norm</a>(input.derived().array(), weights.derived().array());</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00140">l2_norm()</a>.</p>

</div>
</div>
<a id="a5d99abe8892d0073763dedb050b95dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d99abe8892d0073763dedb050b95dd3">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;VECTOR&gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1details_1_1WrapFunction.html">details::WrapFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>direct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsopt_1_1details_1_1WrapFunction.html">details::WrapFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>adjoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a linear transform from a pair of wrappers. </p>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00130">130</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="keywordflow">return</span> {direct, adjoint};</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a09baebf7a38995a5fde7f7b4130ddcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09baebf7a38995a5fde7f7b4130ddcbe">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DERIVED &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">DERIVED::Scalar</a>&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DERIVED &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to creates a function operator. </p>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00211">211</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                       {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  details::MatrixToLinearTransform&lt;Matrix&lt;typename DERIVED::Scalar&gt;&gt; <span class="keyword">const</span> matrix(A);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="keywordflow">if</span> (A.rows() == A.cols())</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keywordflow">return</span> {matrix, matrix.adjoint()};</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a> <span class="keyword">const</span> <a class="code" href="namespacesopt_1_1details.html#a19d03d9b49ed12e7f7b91cb8b19e1db2">gcd</a> = <a class="code" href="namespacesopt_1_1details.html#a19d03d9b49ed12e7f7b91cb8b19e1db2">details::gcd</a>(A.cols(), A.rows());</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a> <span class="keyword">const</span> <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a> = A.cols() / <a class="code" href="namespacesopt_1_1details.html#a19d03d9b49ed12e7f7b91cb8b19e1db2">gcd</a>;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a> <span class="keyword">const</span> <a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a> = A.rows() / <a class="code" href="namespacesopt_1_1details.html#a19d03d9b49ed12e7f7b91cb8b19e1db2">gcd</a>;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">return</span> {matrix, matrix.adjoint(), {{<a class="code" href="bisection__method_8cc.html#a63a56f8266f9d4e2b7904199812311c4">b</a>, <a class="code" href="bisection__method_8cc.html#abe0def96c0a846f46d6fe7c115ff2a7f">a</a>, 0}}};</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_1_1details_html_a19d03d9b49ed12e7f7b91cb8b19e1db2"><div class="ttname"><a href="namespacesopt_1_1details.html#a19d03d9b49ed12e7f7b91cb8b19e1db2">sopt::details::gcd</a></div><div class="ttdeci">t_int gcd(t_int a, t_int b)</div><div class="ttdoc">Greatest common divisor.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00207">maths.h:207</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="bisection__method_8cc_source.html#l00013">a</a>, <a class="el" href="linear__transform_8h_source.html#l00169">sopt::details::MatrixToLinearTransform&lt; EIGEN &gt;::adjoint()</a>, <a class="el" href="bisection__method_8cc_source.html#l00014">b</a>, and <a class="el" href="maths_8h_source.html#l00207">sopt::details::gcd()</a>.</p>

</div>
</div>
<a id="a74ca3f91c20ceee3bb34066eda6824b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ca3f91c20ceee3bb34066eda6824b8">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;VECTOR&gt;&amp; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>passthrough</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience no-op function. </p>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00125">125</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                                                                                {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordflow">return</span> passthrough;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a27b8391ddefe157e732bebe05696170e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b8391ddefe157e732bebe05696170e">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;VECTOR&gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>direct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>{{1,&#160;1,&#160;0}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to creates a function operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>function with signature void(VECTOR&amp;, VECTOR const&amp;) which applies a linear operator to a vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>function with signature void(VECTOR&amp;, VECTOR const&amp;) which applies a the conjugate transpose linear operator to a vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>3 integer elements (a, b, c) such that if the input to linear operator is of size N, then the output is of size (a * N) / b + c. A similar quantity is deduced for the indirect operator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00101">101</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                                                                           {{1, 1, 0}}) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">return</span> {direct, indirect, sizes};</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="sdmm_8h_source.html#l00090">sopt::algorithm::SDMM&lt; SCALAR &gt;::append()</a>, <a class="el" href="examples_2power__method_8cc_source.html#l00005">main()</a>, <a class="el" href="imaging__forward__backward_8h_source.html#l00229">sopt::algorithm::ImagingForwardBackward&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="imaging__padmm_8h_source.html#l00180">sopt::algorithm::ImagingProximalADMM&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="imaging__primal__dual_8h_source.html#l00219">sopt::algorithm::ImagingPrimalDual&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="l2__forward__backward_8h_source.html#l00197">sopt::algorithm::L2ForwardBackward&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="padmm_8h_source.html#l00177">sopt::algorithm::ProximalADMM&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="primal__dual_8h_source.html#l00221">sopt::algorithm::PrimalDual&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="tv__primal__dual_8h_source.html#l00217">sopt::algorithm::TVPrimalDual&lt; SCALAR &gt;::Phi()</a>, <a class="el" href="imaging__primal__dual_8h_source.html#l00230">sopt::algorithm::ImagingPrimalDual&lt; SCALAR &gt;::Psi()</a>, <a class="el" href="l1__proximal_8h_source.html#l00093">sopt::proximal::L1TightFrame&lt; SCALAR &gt;::Psi()</a>, <a class="el" href="primal__dual_8h_source.html#l00227">sopt::algorithm::PrimalDual&lt; SCALAR &gt;::Psi()</a>, <a class="el" href="tv__primal__dual_8h_source.html#l00228">sopt::algorithm::TVPrimalDual&lt; SCALAR &gt;::Psi()</a>, and <a class="el" href="tests_2power__method_8cc_source.html#l00010">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a424b3b158a6f6c45c97eb244c688b429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424b3b158a6f6c45c97eb244c688b429">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;VECTOR&gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>direct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>dsizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#aa4353f012100677172534381f2801fa9">OperatorFunction</a>&lt; VECTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a>, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>isizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to creates a function operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>function with signature void(VECTOR&amp;, VECTOR const&amp;) which applies a linear operator to a vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dsizes</td><td>3 integer elements (a, b, c) such that if the input to the linear operator is of size N, then the output is of size (a * N) / b + c. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>function with signature void(VECTOR&amp;, VECTOR const&amp;) which applies a the conjugate transpose linear operator to a vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dsizes</td><td>3 integer elements (a, b, c) such that if the input to the indirect linear operator is of size N, then the output is of size (a * N) / b + c. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00116">116</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                                                                           {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">return</span> {direct, dsizes, indirect, isizes};</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57b3045c6210eedfab02fd8faf71c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b3045c6210eedfab02fd8faf71c18a">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1Sampling.html">Sampling</a> const &amp;&#160;</td>
          <td class="paramname"><em>sampling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns linear transform version of this object. </p>

<p class="definition">Definition at line <a class="el" href="sampling_8h_source.html#l00082">82</a> of file <a class="el" href="sampling_8h_source.html">sampling.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                                                                      {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">return</span> linear_transform&lt;Vector&lt;T&gt;&gt;(</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      [sampling](<a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;</a> &amp;out, <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;</a> <span class="keyword">const</span> &amp;x) { sampling(out, x); },</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      {{0, 1, <span class="keyword">static_cast&lt;</span><a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a><span class="keyword">&gt;</span>(sampling.rows())}},</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      [sampling](<a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;</a> &amp;out, <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;</a> <span class="keyword">const</span> &amp;x) { sampling.adjoint(out, x); },</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      {{0, 1, <span class="keyword">static_cast&lt;</span><a class="code" href="namespacesopt.html#a47796df8f5f6bbffc226292ef1ca8196">t_int</a><span class="keyword">&gt;</span>(sampling.cols())}});</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="sampling_8h_source.html#l00070">sopt::Sampling::adjoint()</a>, <a class="el" href="sampling_8h_source.html#l00046">sopt::Sampling::cols()</a>, and <a class="el" href="sampling_8h_source.html#l00048">sopt::Sampling::rows()</a>.</p>

</div>
</div>
<a id="a5e3985419d8cc35852bff69d403aef8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3985419d8cc35852bff69d403aef8a">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1wavelets_1_1SARA.html">wavelets::SARA</a> const &amp;&#160;</td>
          <td class="paramname"><em>sara</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thin linear-transform wrapper around 1d sara operator. </p>
<dl class="section note"><dt>Note</dt><dd>Because of the way Purify defines things, Ψ^T is actually the transform from signal to coefficients. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wavelets_8h_source.html#l00183">183</a> of file <a class="el" href="wavelets_8h_source.html">wavelets.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                                                                      {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keywordflow">return</span> details::linear_transform&lt;T, wavelets::SARA&gt;(sara);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c445e577476358820c5cef07f4e3998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c445e577476358820c5cef07f4e3998">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1wavelets_1_1SARA.html">wavelets::SARA</a> const &amp;&#160;</td>
          <td class="paramname"><em>sara</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a>&#160;</td>
          <td class="paramname"><em>cols</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thin linear-transform wrapper around 2d wavelets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sara</td><td>SARA wavelet dictionary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>Number of rows in the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>Number of columns in the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Because of the way Purify defines things, Ψ^T is actually the transform from signal to coefficients. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wavelets_8h_source.html#l00202">202</a> of file <a class="el" href="wavelets_8h_source.html">wavelets.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                                                             {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="keywordflow">return</span> details::linear_transform&lt;T, wavelets::SARA&gt;(sara, <a class="code" href="credible__region_8cc.html#a1cc6c6d663c5f0c6cbd63b69ca306721">rows</a>, <a class="code" href="credible__region_8cc.html#a4f8d1cebdd1d0572b0f5ff58464b9216">cols</a>, sara.size());</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;}</div>
<div class="ttc" id="acredible__region_8cc_html_a1cc6c6d663c5f0c6cbd63b69ca306721"><div class="ttname"><a href="credible__region_8cc.html#a1cc6c6d663c5f0c6cbd63b69ca306721">rows</a></div><div class="ttdeci">t_uint rows</div><div class="ttdef"><b>Definition:</b> <a href="credible__region_8cc_source.html#l00012">credible_region.cc:12</a></div></div>
<div class="ttc" id="acredible__region_8cc_html_a4f8d1cebdd1d0572b0f5ff58464b9216"><div class="ttname"><a href="credible__region_8cc.html#a4f8d1cebdd1d0572b0f5ff58464b9216">cols</a></div><div class="ttdeci">t_uint cols</div><div class="ttdef"><b>Definition:</b> <a href="credible__region_8cc_source.html#l00013">credible_region.cc:13</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="credible__region_8cc_source.html#l00013">cols</a>, and <a class="el" href="credible__region_8cc_source.html#l00012">rows</a>.</p>

</div>
</div>
<a id="a43b77806f4ddf6e970dbb6b03613e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b77806f4ddf6e970dbb6b03613e39f">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1wavelets_1_1Wavelet.html">wavelets::Wavelet</a> const &amp;&#160;</td>
          <td class="paramname"><em>wavelet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thin linear-transform wrapper around 1d wavelets. </p>
<dl class="section warning"><dt>Warning</dt><dd>Because of the way Purify defines things, Ψ^T is actually the transform from signal to coefficients. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wavelets_8h_source.html#l00175">175</a> of file <a class="el" href="wavelets_8h_source.html">wavelets.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                                                            {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordflow">return</span> details::linear_transform&lt;T, wavelets::Wavelet&gt;(wavelet);</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2d9a54108659a468d1a4c2177d7a88b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9a54108659a468d1a4c2177d7a88b0">&#9670;&nbsp;</a></span>linear_transform() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; &gt; sopt::linear_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1wavelets_1_1Wavelet.html">wavelets::Wavelet</a> const &amp;&#160;</td>
          <td class="paramname"><em>wavelet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7237c0991f6ec8c2bbdab8929b564964">t_uint</a>&#160;</td>
          <td class="paramname"><em>cols</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thin linear-transform wrapper around 2d wavelets. </p>
<dl class="section note"><dt>Note</dt><dd>Because of the way Purify defines things, Ψ^T is actually the transform from signal to coefficients. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wavelets_8h_source.html#l00191">191</a> of file <a class="el" href="wavelets_8h_source.html">wavelets.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                                             {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="keywordflow">return</span> details::linear_transform&lt;T, wavelets::Wavelet&gt;(wavelet, <a class="code" href="credible__region_8cc.html#a1cc6c6d663c5f0c6cbd63b69ca306721">rows</a>, <a class="code" href="credible__region_8cc.html#a4f8d1cebdd1d0572b0f5ff58464b9216">cols</a>);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="credible__region_8cc_source.html#l00013">cols</a>, and <a class="el" href="credible__region_8cc_source.html#l00012">rows</a>.</p>

</div>
</div>
<a id="abf425c6640b07e4b2718d0a0db4c9cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf425c6640b07e4b2718d0a0db4c9cdd">&#9670;&nbsp;</a></span>linear_transform_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsopt_1_1LinearTransform.html">LinearTransform</a>&lt;<a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;SCALAR&gt; &gt; sopt::linear_transform_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a linear transform that's just the identity. </p>

<p class="definition">Definition at line <a class="el" href="linear__transform_8h_source.html#l00226">226</a> of file <a class="el" href="linear__transform_8h_source.html">linear_transform.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                                            {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="keywordflow">return</span> {[](<a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;SCALAR&gt;</a> &amp;out, <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;SCALAR&gt;</a> <span class="keyword">const</span> &amp;in) { out = in; },</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;          [](<a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;SCALAR&gt;</a> &amp;out, <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;SCALAR&gt;</a> <span class="keyword">const</span> &amp;in) { out = in; }};</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1f7fdbcc2c8d7cdde37b39c2a14ddbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f7fdbcc2c8d7cdde37b39c2a14ddbb">&#9670;&nbsp;</a></span>number_of_threads_in_tests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t sopt::number_of_threads_in_tests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads used during testing. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00051">51</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{ <span class="keywordflow">return</span> @SOPT_DEFAULT_OPENMP_THREADS@; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a430768559bd58eab9a93942fb99d1918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430768559bd58eab9a93942fb99d1918">&#9670;&nbsp;</a></span>positive_quadrant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::CwiseUnaryOp&lt;const <a class="el" href="classsopt_1_1details_1_1ProjectPositiveQuadrant.html">details::ProjectPositiveQuadrant</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a>&gt;, const T&gt; sopt::positive_quadrant </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expression to create projection onto positive quadrant. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00060">60</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                  {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="keyword">using</span> Projector = details::ProjectPositiveQuadrant&lt;typename T::Scalar&gt;;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keyword">using</span> UnaryOp = Eigen::CwiseUnaryOp&lt;const Projector, const T&gt;;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="keywordflow">return</span> UnaryOp(input.derived(), Projector());</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="examples_2l1__proximal_8cc_source.html#l00005">main()</a>, <a class="el" href="proximal_8h_source.html#l00151">sopt::proximal::positive_quadrant()</a>, and <a class="el" href="maths_8cc_source.html#l00013">TEST_CASE()</a>.</p>

</div>
</div>
<a id="ad7fbfa0f1f262d124020ccaf5e6cb573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fbfa0f1f262d124020ccaf5e6cb573">&#9670;&nbsp;</a></span>sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;T&gt;::type sopt::sigma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inpainting_8h_source.html#l00017">17</a> of file <a class="el" href="inpainting_8h_source.html">inpainting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                                                             {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keyword">auto</span> constexpr snr = 30.0;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> y0 = <a class="code" href="namespacesopt.html#a83a82628fe55e720accd252a72c7337c">target</a>(sampling, image);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <span class="keywordflow">return</span> y0.stableNorm() / std::sqrt(y0.size()) * std::pow(10.0, -(snr / 20.0));</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="inpainting_8h_source.html#l00012">target()</a>.</p>

<p class="reference">Referenced by <a class="el" href="inpainting_8h_source.html#l00025">dirty()</a>, <a class="el" href="inpainting_8h_source.html#l00038">epsilon()</a>, <a class="el" href="onnx__differentiable__func_8h_source.html#l00107">sopt::ONNXDifferentiableFunc&lt; SCALAR &gt;::function()</a>, <a class="el" href="onnx__differentiable__func_8h_source.html#l00080">sopt::ONNXDifferentiableFunc&lt; SCALAR &gt;::gradient()</a>, <a class="el" href="l2__differentiable__func_8h_source.html#l00020">sopt::L2DifferentiableFunc&lt; SCALAR &gt;::L2DifferentiableFunc()</a>, <a class="el" href="examples_2forward__backward_2inpainting_8cc_source.html#l00024">main()</a>, and <a class="el" href="tests_2inpainting_8cc_source.html#l00032">TEST_CASE()</a>.</p>

</div>
</div>
<a id="ac02ea9b606e6a1eef171de3447c77bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02ea9b606e6a1eef171de3447c77bc1">&#9670;&nbsp;</a></span>soft_threshhold() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::CwiseUnaryOp&lt;const <a class="el" href="namespacesopt_1_1details.html#a9b2c8778a2d73aff0499c9f899fe16df">details::SoftThreshhold</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a>&gt;, const T&gt; sopt::soft_threshhold </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a> &gt;::type const &amp;&#160;</td>
          <td class="paramname"><em>threshhold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expression to create soft-threshhold. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00068">68</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                                                {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keyword">using</span> <a class="code" href="bisection__method_8cc.html#aa0bfbe32b639db5c015dd41a0ac7ca35">Scalar</a> = <span class="keyword">typename</span> <a class="code" href="bisection__method_8cc.html#aa0bfbe32b639db5c015dd41a0ac7ca35">T::Scalar</a>;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keyword">using</span> Real = <span class="keyword">typename</span> real_type&lt;Scalar&gt;::type;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keywordflow">return</span> Eigen::CwiseUnaryOp&lt;const details::SoftThreshhold&lt;typename T::Scalar&gt;, <span class="keyword">const</span> T&gt;{</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      input.derived(), std::bind(soft_threshhold&lt;Scalar&gt;, std::placeholders::_1, Real(threshhold))};</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div>
<div class="ttc" id="abisection__method_8cc_html_aa0bfbe32b639db5c015dd41a0ac7ca35"><div class="ttname"><a href="bisection__method_8cc.html#aa0bfbe32b639db5c015dd41a0ac7ca35">Scalar</a></div><div class="ttdeci">sopt::t_real Scalar</div><div class="ttdef"><b>Definition:</b> <a href="bisection__method_8cc_source.html#l00009">bisection_method.cc:9</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3047abf694788f24705a1c656a250510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3047abf694788f24705a1c656a250510">&#9670;&nbsp;</a></span>soft_threshhold() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::value and std::is_arithmetic&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a>&gt;::value, Eigen::CwiseBinaryOp&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> (*)(typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;, typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a> const &amp;), const T0, const T1&gt; &gt;::type sopt::soft_threshhold </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>threshhold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expression to create soft-threshhold with multiple parameters. </p>
<p>Operates over a vector of threshholds: <code>out(i) = soft_threshhold(x(i), h(i))</code> Threshhold and input vectors must have the same size and type. The latter condition is enforced by CwiseBinaryOp, unfortunately. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00087">87</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">if</span> (input.size() != threshhold.size())</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <a class="code" href="exception_8h.html#a57974308768f9fafc7107b626a394f4f">SOPT_THROW</a>(<span class="stringliteral">&quot;Threshhold and input should have the same size&quot;</span>);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordflow">return</span> {input.derived(), threshhold.derived(), soft_threshhold&lt;typename T0::Scalar&gt;};</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="exception_8h_source.html#l00046">SOPT_THROW</a>.</p>

</div>
</div>
<a id="aa14309c45de330f8915e1ffd75fa8164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14309c45de330f8915e1ffd75fa8164">&#9670;&nbsp;</a></span>soft_threshhold() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structsopt_1_1is__complex.html">is_complex</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::value and std::is_arithmetic&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T1::Scalar</a>&gt;::value, Eigen::CwiseBinaryOp&lt; typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> (*)(typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;, typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a> const &amp;), const T0, decltype(std::declval&lt;const T1&gt;).template cast&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;))&gt; &gt;::type sopt::soft_threshhold </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>threshhold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expression to create soft-threshhold with multiple parameters. </p>
<p>Operates over a vector of threshholds: <code>out(i) = soft_threshhold(x(i), h(i))</code> Threshhold and input vectors must have the same size and type. The latter condition is enforced by CwiseBinaryOp, unfortunately. So we cast threshhold from real to complex and back. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00103">103</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">if</span> (input.size() != threshhold.size())</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <a class="code" href="exception_8h.html#a57974308768f9fafc7107b626a394f4f">SOPT_THROW</a>(<span class="stringliteral">&quot;Threshhold and input should have the same size: &quot;</span>)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        &lt;&lt; threshhold.size() &lt;&lt; <span class="stringliteral">&quot; vs &quot;</span> &lt;&lt; input.size();</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="keyword">using</span> Complex = <span class="keyword">typename</span> <a class="code" href="bisection__method_8cc.html#aa0bfbe32b639db5c015dd41a0ac7ca35">T0::Scalar</a>;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> func = [](Complex <span class="keyword">const</span> &amp;x, Complex <span class="keyword">const</span> &amp;t) -&gt; Complex {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#aa14309c45de330f8915e1ffd75fa8164">soft_threshhold</a>(x, t.real());</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  };</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="keywordflow">return</span> {input.derived(), threshhold.derived().template cast&lt;Complex&gt;(), func};</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_html_aa14309c45de330f8915e1ffd75fa8164"><div class="ttname"><a href="namespacesopt.html#aa14309c45de330f8915e1ffd75fa8164">sopt::soft_threshhold</a></div><div class="ttdeci">std::enable_if&lt; is_complex&lt; typename T0::Scalar &gt;::value and std::is_arithmetic&lt; typename T1::Scalar &gt;::value, Eigen::CwiseBinaryOp&lt; typename T0::Scalar(*)(typename T0::Scalar const &amp;, typename T0::Scalar const &amp;), const T0, decltype(std::declval&lt; const T1 &gt;).template cast&lt; typename T0::Scalar &gt;))&gt; &gt;::type soft_threshhold(Eigen::DenseBase&lt; T0 &gt; const &amp;input, Eigen::DenseBase&lt; T1 &gt; const &amp;threshhold)</div><div class="ttdoc">Expression to create soft-threshhold with multiple parameters.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00103">maths.h:103</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00029">soft_threshhold()</a>, and <a class="el" href="exception_8h_source.html#l00046">SOPT_THROW</a>.</p>

</div>
</div>
<a id="a6494afff8ee7f1196ff67ce646359d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6494afff8ee7f1196ff67ce646359d3e">&#9670;&nbsp;</a></span>soft_threshhold() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;SCALAR&gt;::value or <a class="el" href="structsopt_1_1is__complex.html">is_complex</a>&lt;SCALAR&gt;::value, SCALAR&gt;::type sopt::soft_threshhold </td>
          <td>(</td>
          <td class="paramtype">SCALAR const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt; SCALAR &gt;::type const &amp;&#160;</td>
          <td class="paramname"><em>threshhold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>abs(x) &lt; threshhold ? 0: x - sgn(x) * threshhold </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00029">29</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> normalized = std::abs(x);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keywordflow">return</span> normalized &lt; threshhold ? SCALAR(0) : (x * (SCALAR(1) - threshhold / normalized));</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="proximal_8h_source.html#l00144">sopt::proximal::l1_norm()</a>, <a class="el" href="examples_2sdmm_2reweighted_8cc_source.html#l00027">main()</a>, <a class="el" href="l1__proximal_8h_source.html#l00128">sopt::proximal::L1TightFrame&lt; SCALAR &gt;::operator()()</a>, <a class="el" href="maths_8h_source.html#l00103">soft_threshhold()</a>, and <a class="el" href="maths_8cc_source.html#l00072">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a239b0c108ec581a5b5f0c39276aefad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b0c108ec581a5b5f0c39276aefad8">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a>&gt;::type sopt::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the standard deviation of a vector. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00016">16</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                                                                                        {</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  <span class="keywordflow">return</span> (x - x.mean()).matrix().stableNorm() / std::sqrt(x.size());</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="reweighted_8h_source.html#l00206">sopt::algorithm::Reweighted&lt; ALGORITHM &gt;::operator()()</a>, <a class="el" href="maths_8h_source.html#l00021">standard_deviation()</a>, and <a class="el" href="tests_2reweighted_8cc_source.html#l00059">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a009292a23363f1e290a92ce6a2786065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009292a23363f1e290a92ce6a2786065">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T::Scalar</a>&gt;::type sopt::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the standard deviation of a vector. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00021">21</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a009292a23363f1e290a92ce6a2786065">standard_deviation</a>(x.array());</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_html_a009292a23363f1e290a92ce6a2786065"><div class="ttname"><a href="namespacesopt.html#a009292a23363f1e290a92ce6a2786065">sopt::standard_deviation</a></div><div class="ttdeci">real_type&lt; typename T::Scalar &gt;::type standard_deviation(Eigen::MatrixBase&lt; T &gt; const &amp;x)</div><div class="ttdoc">Computes the standard deviation of a vector.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00021">maths.h:21</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00016">standard_deviation()</a>.</p>

</div>
</div>
<a id="a83a82628fe55e720accd252a72c7337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a82628fe55e720accd252a72c7337c">&#9670;&nbsp;</a></span>target()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt;T&gt; sopt::target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsopt_1_1LinearTransform.html">sopt::LinearTransform</a>&lt; <a class="el" href="namespacesopt.html#ac4dd3feebe1bf49ebd44d72b05064c19">Vector</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesopt.html#a7d7971e5566e597eb907614917e30c78">sopt::Image</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inpainting_8h_source.html#l00012">12</a> of file <a class="el" href="inpainting_8h_source.html">inpainting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  <span class="keywordflow">return</span> sampling * <a class="code" href="tests_2inpainting_8cc.html#a47c194cae73625ab3a13b62e4234f46f">Vector&lt;T&gt;::Map</a>(image.data(), image.size());</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="inpainting_8h_source.html#l00025">dirty()</a>, <a class="el" href="inpainting_8h_source.html#l00038">epsilon()</a>, <a class="el" href="l2__forward__backward_8h_source.html#l00151">sopt::algorithm::L2ForwardBackward&lt; SCALAR &gt;::operator()()</a>, <a class="el" href="inpainting_8h_source.html#l00017">sigma()</a>, <a class="el" href="l2__forward__backward_8h_source.html#l00144">sopt::algorithm::L2ForwardBackward&lt; SCALAR &gt;::target()</a>, and <a class="el" href="primal__dual_8cc_source.html#l00020">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a1967222064d29c760e307ece5da21168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1967222064d29c760e307ece5da21168">&#9670;&nbsp;</a></span>tv_norm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::tv_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted tv norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00192">192</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="keyword">typename</span> T0::PlainObject w(1);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  w(0) = 1;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">tv_norm</a>(input, w);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div>
<div class="ttc" id="anamespacesopt_html_a96b301acf3c109ea862ff9e563d2a164"><div class="ttname"><a href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">sopt::tv_norm</a></div><div class="ttdeci">real_type&lt; typename T0::Scalar &gt;::type tv_norm(Eigen::MatrixBase&lt; T0 &gt; const &amp;input)</div><div class="ttdoc">Computes weighted TV norm.</div><div class="ttdef"><b>Definition:</b> <a href="maths_8h_source.html#l00199">maths.h:199</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00168">tv_norm()</a>.</p>

</div>
</div>
<a id="a1f08c74e9b2cac9f30e52c2c6bdbd0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f08c74e9b2cac9f30e52c2c6bdbd0f5">&#9670;&nbsp;</a></span>tv_norm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::tv_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::ArrayBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::ArrayBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted TV norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00168">168</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> size = input.size() / 2;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="keywordflow">if</span> (weights.size() == 1)</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">return</span> (input.segment(0, size).square() + input.segment(size, size).square())</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;               .cwiseAbs()</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;               .sqrt()</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;               .matrix()</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;               .sum() *</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;           std::abs(weights(0));</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">return</span> std::abs(</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      ((input.segment(0, size).square() + input.segment(size, size).square()).cwiseAbs().sqrt() *</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;       weights)</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;          .matrix()</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;          .sum());</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="maths_8h_source.html#l00186">tv_norm()</a>.</p>

</div>
</div>
<a id="a96b301acf3c109ea862ff9e563d2a164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b301acf3c109ea862ff9e563d2a164">&#9670;&nbsp;</a></span>tv_norm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::tv_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted TV norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00199">199</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="keyword">typename</span> T0::PlainObject w(1);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  w(0) = 1;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">tv_norm</a>(input.derived().array(), w.array());</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00168">tv_norm()</a>.</p>

</div>
</div>
<a id="ae0a7db0a39348c31cdb1475fbeb26c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a7db0a39348c31cdb1475fbeb26c84">&#9670;&nbsp;</a></span>tv_norm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesopt.html#a7ee75936aaae93251b12abb77c3e02aa">real_type</a>&lt;typename <a class="el" href="tf__model_8cc.html#a8c2981f3f834be9448a6ab06c28748eb">T0::Scalar</a>&gt;::type sopt::tv_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; T0 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weighted TV norm. </p>

<p class="definition">Definition at line <a class="el" href="maths_8h_source.html#l00186">186</a> of file <a class="el" href="maths_8h_source.html">maths.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacesopt.html#a96b301acf3c109ea862ff9e563d2a164">tv_norm</a>(input.derived().array(), weights.derived().array());</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maths_8h_source.html#l00168">tv_norm()</a>.</p>

</div>
</div>
<a id="aad09b58521217893f8f6bb076ade261b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad09b58521217893f8f6bb076ade261b">&#9670;&nbsp;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sopt::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns library version. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00032">32</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;@SOPT_VERSION@&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67e58ea24374aec8759a251b307a0af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e58ea24374aec8759a251b307a0af4">&#9670;&nbsp;</a></span>version_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;uint8_t, uint8_t, uint8_t&gt; sopt::version_tuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns library version. </p>

<p class="definition">Definition at line <a class="el" href="config_8in_8h_source.html#l00035">35</a> of file <a class="el" href="config_8in_8h_source.html">config.in.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                                                           {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="keywordflow">return</span> std::tuple&lt;uint8_t, uint8_t, uint8_t&gt;(</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      @SOPT_VERSION_MAJOR@, @SOPT_VERSION_MINOR@, @SOPT_VERSION_PATCH@);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
